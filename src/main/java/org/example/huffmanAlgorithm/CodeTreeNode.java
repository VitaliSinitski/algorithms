package org.example.huffmanAlgorithm;

// класс для представления кодового дерева
public class CodeTreeNode implements Comparable<CodeTreeNode> {
    Character content;   // символ
    int weight;     // частота для листа или сумма частот дочерних узлов для промежуточного узла
    CodeTreeNode left;  // левый потомок
    CodeTreeNode right; // правый потомок

    public CodeTreeNode(Character content, int weight) {
        this.content = content;
        this.weight = weight;
    }

    public CodeTreeNode(Character content, int weight, CodeTreeNode left, CodeTreeNode right) {
        this.content = content;
        this.weight = weight;
        this.left = left;
        this.right = right;
    }

    @Override
    public int compareTo(CodeTreeNode o) {
        // при сравнении сравниваем веса(частоты), у кого вес больше, тот и стоит первее
        return o.weight - weight;
    }

    // этот метод осуществляет проход по кодовому дереву от корня до конкретного символа
    // при этом по поворотам направо и налево вычисляет последовательность 0 и 1, которые будут кодом данного символа

    // в качестве параметров метод принимает символ для которого мы ищем код и путь в виде 0 и 1,
    // в котором при сворачивании влево мы будем дописывать 0, а при сворачивании вправо 1
    public String getCodeForCharacter(Character ch, String parentPath) {
        // если контентом текущего узла является символ, который мы ищем, то тогда мы дошли до нужного нам листа
        // и в переменной parentPath уже есть нужный нам код
        if (content == ch) {
            // и мы просто возвращаем parentPath
            return parentPath;
        } else {
            // если у узла есть левый потомок
            if (left != null) {
                // вызываем у него рекурсивно тот же метод
                // передаем в него символ, который мы ищем и дописываем к его пути символ '0'
                String path = left.getCodeForCharacter(ch, parentPath + 0);
                // если полученный путь != null
                // это будет означать, что в левом поддереве данного узла нашелся нужный нам узел, который мы ищем
                if (path != null) {
                    // тогда этот путь нам надо вернуть (то есть этот путь уже содержит в себе код)
                    return path;
                }
            }
            // если есть правое поддерево, с ним повторяем то же самое
            if (right != null) {
                // вызываем у него рекурсивно тот же метод
                // передаем в него символ, который мы ищем и дописываем к его пути символ '1', так как это поворот направо
                String path = right.getCodeForCharacter(ch, parentPath + 1);
                // если полученный путь != null
                // это будет означать, что в правом поддереве данного узла нашелся нужный нам узел, который мы ищем
                if (path != null) {
                    // тогда этот путь нам надо вернуть (то есть этот путь уже содержит в себе код)
                    return path;
                }
            }
        }
        // если не сработал не один и не второй return, то это означает, что мы находимся в листе
        // но в этом листе не тот символ, который мы ищем
        // и это означает, что это не тот путь, который нам нужен (сигнализируем о неудачном поиске в данном поддереве
        // возвращаем null
        return null;

        // данный алгоритм делаем обход дерева в глубину
        // для всех листов, которые не соответствует тому который мы ищем, то есть в которых контент не равен искомому символу будет возращено null в качестве кода
        // и только для одного узла, который мы ищем, вернется код
        // и он всплывет при обходе по деревьям наверх и будет возвращен в качестве результата вызова самого верхнего (в стеке) метода
        // это обычный поиск в дереве рекурсивным обходом
    }
}
