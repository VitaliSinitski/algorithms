package org.example.recursion;

import java.util.Arrays;

public class MergeSort {

    public static void main(String[] params) {
        int[] array = {2, 7, 9, 1, 8, 6, 4, 3, 5};
//        int[] array = {15, 78, 89, 9, 12, 12546, 8, 879, 16, 54, 1};
        System.out.println(Arrays.toString(array));
        mergeSort(array, 0, array.length - 1);
        System.out.println(Arrays.toString(array));
    }

    /*
     * Сортировка слиянием (merge sort) использует именно тот подход, когда берутся два отсортированных массива и сливаются в один.
     * Основная идея заключается в разделении исходного массива на половины,
     *      рекурсивной сортировке каждой половины и затем слиянии отсортированных половин в один отсортированный массив.
     *
     * Вызывается метод `mergeSort(array, 0, array.length - 1)`,
     *      передавая исходный массив, индекс начала (0) и индекс конца (длина массива - 1).
     *
     * В методе `mergeSort(int[] array, int left, int right)` проверяется условие `left < right`,
     *      которое определяет, что в массиве есть более одного элемента, которые нужно отсортировать.
     * Вычисляется индекс `mid`, который представляет середину массива.
     * Рекурсивно вызывается `mergeSort(array, left, mid)`, что приводит к сортировке левой половины массива (от `left` до `mid`).
     * Рекурсивно вызывается `mergeSort(array, mid + 1, right)`, что приводит к сортировке правой половины массива (от `mid + 1` до `right`).
     * Вызывается метод `merge(array, left, mid, right)`, который выполняет слияние двух отсортированных половин массива.
     *
     * В методе `merge` создается временный массив `temp`, который будет использоваться для слияния.
     * Инициализируются индексы `i` для левой половины, `j` для правой половины и `k` для временного массива.
     * В цикле `while` происходит сравнение элементов из левой и правой половин массива.
     *      Если элемент из левой половины меньше или равен элементу из правой половины,
     *          он записывается во временный массив `temp`, и индекс `i` увеличивается на 1.
     *      Если элемент из правой половины меньше, то он записывается во временный массив `temp`,
     *          и индекс `j` увеличивается на 1. Индекс `k` увеличивается на 1 после каждой записи во временный массив.
     * После выполнения цикла `while` проверяются условия, остались ли элементы только в левой или правой половине.
     *      Если остались, они копируются во временный массив `temp`.
     * Затем элементы из временного массива `temp` копируются обратно в исходный массив `array` в правильном порядке.
     */
    public static void mergeSort(int[] array, int left, int right) {
        // (left < right) определяет, что в массиве есть более одного элемента, которые нужно отсортировать
        if (left < right) {
            // вычисляется индекс mid, который представляет середину массива
            int mid = (left + right) / 2;
            //  рекурсивно вызывается mergeSort(array, left, mid), что приводит к сортировке левой половины массива (от left до mid)
            mergeSort(array, left, mid);
            // рекурсивно вызывается mergeSort(array, mid + 1, right), что приводит к сортировке правой половины массива (от mid + 1 до right)
            mergeSort(array, mid + 1, right);
            // слияние двух отсортированных половин
            merge(array, left, mid, right);
        }
    }

    private static void merge(int[] array, int left, int mid, int right) {
        // создание временного массива для слияния
        int[] temp = new int[right - left + 1];
        // индекс для левой половины
        int i = left;
        // индекс для правой половины
        int j = mid + 1;
        // индекс для временного массива
        int k = 0;
        // в цикле while происходит сравнение элементов из левой и правой половин массива
        while (i <= mid && j <= right) {
            // если элемент из левой половины меньше или равен элементу из правой половины
            if (array[i] <= array[j]) {
                // он (элемента из левой половины) записывается во временный массив temp
                temp[k] = array[i];
                // индекс i (индекс левой половины) увеличивается на 1
                i++;
            // если элемент из правой половины меньше
            } else {
                // то он (элемента из правой половины) записывается во временный массив temp
                temp[k] = array[j];
                // и индекс j (индекс правой половины) увеличивается на 1
                j++;
            }
            // индекс k увеличивается на 1 после каждой записи во временный массив.
            k++;
        }

        // Если остались элементы только в левой половине
        while (i <= mid) {
            // Запись оставшихся элементов из левой половины во временный массив
            temp[k] = array[i];
            i++;
            k++;
        }

        // Если остались элементы только в правой половине
        while (j <= right) {
            // Запись оставшихся элементов из правой половины во временный массив
            temp[k] = array[j];
            j++;
            k++;
        }

        // Копирование отсортированных элементов из временного массива обратно в исходный массив
        for (int m = 0; m < temp.length; m++) {
            array[left + m] = temp[m];
        }
    }
}

