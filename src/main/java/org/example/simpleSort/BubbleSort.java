package org.example.simpleSort;

import java.util.Arrays;

public class BubbleSort {
    public static void main(String[] args) {
        int[] array = {3, 6, 82, 24, 14, 28, 2, 9, 27, 10, 4, 42};
        bubbleSort(array);
        System.out.println(Arrays.toString(array));
    }

    /*
     * Внешний цикл выполняется для прохода по элементам массива с конца до второго (или первого?) элемента.
     * Внутренний цикл выполняется для сравнения пар соседних элементов.
     * Если текущий элемент больше следующего элемента, вызывается метод swap для их обмена.
     * После завершения внутреннего цикла наибольший элемент смещается в конец массива.
     * Внешний цикл повторяется, уменьшая длину прохода на каждой итерации.
     * Повторяем эти шаги до тех пор, пока массив не будет полностью отсортирован по возрастанию.
     */
    private static void bubbleSort(int[] array) {
        for (int i = array.length - 1; i > 1; i--) {  // Внешний цикл для прохода по элементам массива с конца до второго элемента
            for (int j = 0; j < i; j++) {  // Внутренний цикл для сравнения пар соседних элементов
                if (array[j] > array[j + 1]) {  // Если текущий элемент больше следующего элемента
                    swap(array, j, j + 1);  // Меняем их местами
                }
            }
        }
    }

    private static void swap(int[] array, int ind1, int ind2) {  // Метод для обмена элементов массива
        int temp = array[ind1];  // Сохраняем значение текущего элемента во временной переменной
        array[ind1] = array[ind2];  // Заменяем текущий элемент на элемент с другим индексом
        array[ind2] = temp;  // Заменяем элемент с другим индексом на сохраненное значение
    }

    /*
     * 1) Внешний цикл for (int i = array.length - 1; i > 1; i--) отслеживает проходы по массиву.
     *    Он начинается с последнего элемента и итерируется до второго элемента.
     *    Каждый проход сокращает длину сортируемой части массива на один элемент.
     * 2) Внутренний цикл for (int j = 0; j < i; j++) проходит по сортируемой части массива от начала до текущей позиции внешнего цикла.
     *    Он сравнивает соседние элементы и выполняет обмен, если текущий элемент больше следующего.
     * 3) После каждого прохода внутреннего цикла наибольший элемент в текущей сортируемой части массива "всплывает" в конец,
     *      таким образом, с каждым проходом максимальный элемент становится на своё место.
     * 4) После завершения внешнего цикла массив будет отсортирован в порядке возрастания.
     */
}
